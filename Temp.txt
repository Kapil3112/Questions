
{% macro array_min(arr) %}
    SELECT MIN(value) AS min_value
    FROM UNNEST({{ arr }}) AS value
{% endmacro %}
SELECT
  "PTY ID",
  "AGRMNT ID",
  "EVENT START DIV",
  "REIATD AGRMNT NO",
  "ABS AMOUNT",
  "EVENT ACTVTY NR CHECK",
  COUNT("EVENT ID") AS debit_credit_count,
  CASE
    WHEN COUNT("EVENT ID") <= (
      SELECT MIN(cnt) FROM (
        SELECT COUNT("EVENT ID") AS cnt
        FROM sorted_dups
        GROUP BY "PTY ID", "AGRMNT ID", "EVENT START DIV", "REIATD AGRMNT NO", "ABS AMOUNT", "EVENT ACTVTY NR CHECK"
      ) subquery
    ) THEN COUNT("EVENT ID")
    ELSE (
      SELECT MIN(cnt) FROM (
        SELECT COUNT("EVENT ID") AS cnt
        FROM sorted_dups
        GROUP BY "PTY ID", "AGRMNT ID", "EVENT START DIV", "REIATD AGRMNT NO", "ABS AMOUNT", "EVENT ACTVTY NR CHECK"
      ) subquery
    )
  END AS match_count
FROM
  sorted_dups
GROUP BY
  "PTY ID", "AGRMNT ID", "EVENT START DIV", "REIATD AGRMNT NO", "ABS AMOUNT", "EVENT ACTVTY NR CHECK"


-- my_model.sql

-- Import necessary dbt packages
{% import "array" as array %}
{% import "dbt_utils" as dbt_utils %}

-- Create 'dups' table using subset of duplicated rows
WITH dups AS (
  SELECT *
  FROM {{ ref('df_all') }}
  WHERE (PTY_ID, EVENT_START_DT, RELATD_AGRMNT_NO, ABS_AMOUNT) IN (
    SELECT PTY_ID, EVENT_START_DT, RELATD_AGRMNT_NO, ABS_AMOUNT
    FROM {{ ref('df_all') }}
    GROUP BY PTY_ID, EVENT_START_DT, RELATD_AGRMNT_NO, ABS_AMOUNT
    HAVING COUNT(*) > 1
  )
)

-- Create 'sorted_dups' table by sorting 'dups' by specified columns
, sorted_dups AS (
  SELECT *
  FROM dups
  ORDER BY PTY_ID, EVENT_START_DT, EVENT_ID
)

-- Calculate 'type_count' using dbt_utils pivot table
, type_count AS (
  SELECT *
  FROM {{ dbt_utils.pivot(
    source_name='sorted_dups',
    value_name='TYPE',
    index_columns=['PTY_ID', 'AGRMNT_ID', 'EVENT_START_DT', 'RELATD_AGRMNT_NO', 'ABS_AMOUNT', 'EVENT_ACTVTY_NR_CHECK'],
    aggregation='nunique'
  ) }}
)

-- Rename 'TYPE' column to 'TYPE_COUNT' in 'type_count' table
, type_count_renamed AS (
  SELECT PTY_ID, AGRMNT_ID, EVENT_START_DT, RELATD_AGRMNT_NO, ABS_AMOUNT, EVENT_ACTVTY_NR_CHECK, "TYPE" AS "TYPE_COUNT"
  FROM type_count
)

-- Join 'sorted_dups' with 'type_count_renamed' table
, sorted_dups_with_type_count AS (
  SELECT *
  FROM sorted_dups
  LEFT JOIN type_count_renamed USING (PTY_ID, AGRMNT_ID, EVENT_START_DT, RELATD_AGRMNT_NO, ABS_AMOUNT, EVENT_ACTVTY_NR_CHECK)
)

-- Filter rows where 'TYPE_COUNT' is 2 in 'sorted_dups_with_type_count' table
, sorted_dups_filtered AS (
  SELECT *
  FROM sorted_dups_with_type_count
  WHERE "TYPE_COUNT" = 2
)

-- Calculate 'debit_credit_count' using dbt_utils pivot table
, debit_credit_count AS (
  SELECT *
  FROM {{ dbt_utils.pivot(
    source_name='sorted_dups_filtered',
    value_name='EVENT_ID',
    index_columns=['PTY_ID', 'AGRMNT_ID', 'RELATD_AGRMNT_NO', 'EVENT_START_DT', 'ABS_AMOUNT', 'EVENT_ACTVTY_NR_CHECK'],
    columns=['TYPE'],
    aggregation='count'
  ) }}
)

-- Calculate 'MATCH_COUNT' and select necessary columns in 'debit_credit_count' table
, debit_credit_count_with_match_count AS (
  SELECT *, {{ array.min(array([col('ELECT', 'MATCH_COUNT') for col in debit_credit_count.column_names()])) }} AS "MATCH_COUNT"
  FROM debit_credit_count
)

-- Reset index in 'debit_credit_count_with_match_count' table
, debit_credit_count_reset_index AS (
  SELECT *
  FROM debit_credit_count_with_match_count
  ORDER BY "MATCH_COUNT"
  LIMIT 1 -- Assuming you only want the row with the minimum "MATCH_COUNT"
)

-- Join

 'sorted_dups_filtered' with 'debit_credit_count_reset_index' table
, sorted_dups_with_match_count AS (
  SELECT *
   FROM sorted_dups_filtered
  LEFT JOIN debit_credit_count_reset_index USING (PTY_ID, AGRMNT_ID, RELATD_AGRMNT_NO, EVENT_START_DT, ABS_AMOUNT, EVENT_ACTVTY_NR_CHECK)
)

-- Calculate 'CUMUL_COUNT' using GROUP BY and cumulative count
, sorted_dups_with_cumul_count AS (
  SELECT *, ROW_NUMBER() OVER (PARTITION BY PTY_ID, AGRMNT_ID, EVENT_START_DT, RELATD_AGRMNT_NO, ABS_AMOUNT, EVENT_ACTVTY_NR_CHECK, "TYPE" ORDER BY EVENT_ID) - 1 AS "CUMUL_COUNT"
  FROM sorted_dups_with_match_count
)

-- Final filtered 'sorted_dups' table with 'CUMUL_COUNT' condition
SELECT *
FROM sorted_dups_with_cumul_count
WHERE "CUMUL_COUNT" < "MATCH_COUNT"
```

In the above dbt SQL code, the different stages of the transformation are broken down into multiple CTEs (Common Table Expressions) to perform the necessary calculations and joins. Each CTE builds on the previous one to achieve the desired result.

Make sure to replace `'df_all'` with the appropriate reference to the source table in your dbt project. Adjust the column names as per your table schema.

Note: This code assumes that you have the necessary dbt packages, such as `array` and `dbt_utils`, installed and configured in your dbt project.



@WITH base_monthly_features AS (
SELECT
PTY_ID, AGRMNT_ID, txn_month, txn_year,
--CASH_OUTFLOW
SUM (CASE WHEN CRT_DBT_IND = 'Debit'
AND OW_FINAL CATEGORY _1 l= 'Exclusion' THEN EVENT_AM ELSE 0 END)
AS CASH_OUTFLOW,
- - CASH_OUTFLOW_COUNT
COUNT (CASE WHEN CRT_DBT_IND = 'Debit' AND OW_FINAL_CATEGORY_1 != 'Exclusion'
AS CASH_OUTFLOW_COUNT,
- - CORPORATION_TAX
SUM(CASE WHEN CRT_DBT_IND = 'Debit'
AND OW_FINAL_CATEGORY_2 = 'Taxes - Corporation' THEN EVENT_AM ELSE 0 END)
AS CORPORATION_TAX,
--TAX_EXPENSES
SUM(CASE WHEN CRT_DBT_IND = 'Debit*
AND OW_FINAL_CATEGORY_1 = 'Taxes' THEN EVENT_AM ELSE Â® END)
AS TAX_EXPENSES,
- UTILITY_EXPENSES
SUM(CASE WHEN CRT_DBT_IND = 'Debit'
AND OW_FINAL_CATEGORY_1 = 'Utilities' THEN EVENT_AM ELSE 0 END)
AS UTILITY_EXPENSES,
-- GROSS_CASH_INFLOW
SUM(CASE WHEN CRT_DBT_IND = 'Credit'
AND OW_FINAL_CATEGORY_1 l= 'Exclusion' THEN EVENT_AM ELSE 0 END)
AS GROSS_CASH_INFLOW,
- LOANS_CREDIT
SUM(CASE WHEN CRT_DBT_IND = 'Credit'
AND OW_FINAL_CATEGORY_1 = 'Loans' THEN EVENT_AM ELSE O END)
AS LOANS_CREDIT,
- -TAXES_CREDIT_CREDIT
SUM(CASE WHEN CRT_DBT_IND = 'Credit'
AND OW_FINAL_CATEGORY _2 = 'Taxes - Credit' THEN EVENT_AM ELSE O END)
AS TAXES_CREDIT_CREDIT,
-DIRECTOR_PAYMENT_CREDIT
SUM(CASE WHEN CRT_DBT_IND = 'Credit'
AND OW_FINAL_CATEGORY_1 IN('Director Payment', 'Director Payment Secondary') TH AS DIRECTOR_PAYMENT_CREDIT,
-CASH_WITHDRAWALS
SUM(CASE WHEN CRT_DBT_IND = 'Debit'
AND OW_FINAL_CATEGORY_1 = 'Cash Withdrawals' THEN EVENT_AM ELSE 0 END)
AS CASH_WITHDRAWALS,
-INTRA_GROUP_IN
SUM(CASE WHEN CRT_DBT_IND = 'Credit'
AND OM_FINAL CATEGORY_1 = "InIna-group Transfer' THEN EVENT_AM ELSE O END)
AS INTRA_GROUP_IN,
-VAT
SUM(CASE WHEN CRT_DBT_IND = 'Debit'
AND OW_FINAL_CATEGORY_2 = 'Taxes - VAT' THEN EVENT_AM ELSE 0 END)
AS VAT,
- -CASH_FLOW_GROSS
SUM(CASE WHEN OW_FINAL_CATEGORY_1 I= 'Exclusions'
THEN EVENT_AM ELSE 0 END)
AS CASH_FLOW_GROSS,
--DEBIT_COUNT
COUNT (CASE WHEN CRT_DBT_IND = 'Debit' AND OW_FINAL_CATEGORY_1 I= 'Exclusions' THE
AS DEBIT_COUNT,
- -INVOICE_FINANCE
SUM (CASE WHEN CRT_DBT_IND = 'Credit'
AND OW_FINAL_CATEGORY_1 = 'Invoice Finance' THEN EVENT_AM ELSE NULL END)
AS INVOICE_FINANCE,
- - INTRA_GROUP_OUT
SUM(CASE WHEN CRT_DBT_IND = 'Debit'
AND OW_FINAL_CATEGORY_1 = 'Intra-group Transfer' THEN EVENT_AM ELSE NULL END)
AS INTRA_GROUP_OUT
FROM { source (' sre_schema', 'tesowcurated") ]} GROUP BY PTY_ID, txn_year, txn_month
